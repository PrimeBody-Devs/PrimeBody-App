'use client';

import { useEffect, useCallback, useRef, useState } from 'react';
import { analytics, trackConversion, trackError, trackPerformance } from '@/lib/analytics';

// Hook for tracking page views
export function usePageTracking(pageName: string, properties?: Record<string, any>) {
  useEffect(() => {
    analytics.page(pageName, properties);
  }, [pageName, properties]);
}

// Hook for tracking scroll depth
export function useScrollTracking(threshold: number = 25) {
  const [maxScrollDepth, setMaxScrollDepth] = useState(0);
  const lastTrackedDepth = useRef(0);

  useEffect(() => {
    const handleScroll = () => {\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n      const documentHeight = document.documentElement.scrollHeight - window.innerHeight;\n      const scrollPercentage = Math.round((scrollTop / documentHeight) * 100);\n\n      if (scrollPercentage > maxScrollDepth) {\n        setMaxScrollDepth(scrollPercentage);\n        \n        // Track at threshold intervals\n        const currentThreshold = Math.floor(scrollPercentage / threshold) * threshold;\n        if (currentThreshold > lastTrackedDepth.current && currentThreshold > 0) {\n          trackConversion.scrollDepth(scrollPercentage, 100);\n          lastTrackedDepth.current = currentThreshold;\n        }\n      }\n    };\n\n    window.addEventListener('scroll', handleScroll, { passive: true });\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, [maxScrollDepth, threshold]);\n\n  return maxScrollDepth;\n}\n\n// Hook for tracking time on page\nexport function useTimeTracking(pageName: string) {\n  const startTime = useRef(Date.now());\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n  const [timeSpent, setTimeSpent] = useState(0);\n\n  useEffect(() => {\n    startTime.current = Date.now();\n    \n    // Track time every 30 seconds\n    intervalRef.current = setInterval(() => {\n      const currentTime = Math.floor((Date.now() - startTime.current) / 1000);\n      setTimeSpent(currentTime);\n      \n      // Track milestone times\n      if (currentTime === 30 || currentTime === 60 || currentTime === 120 || currentTime === 300) {\n        analytics.track('time_on_page_milestone', 'engagement', {\n          page: pageName,\n          timeSpent: currentTime,\n        });\n      }\n    }, 1000);\n\n    // Track final time on page unload\n    const handleBeforeUnload = () => {\n      const finalTime = Math.floor((Date.now() - startTime.current) / 1000);\n      analytics.track('time_on_page_final', 'engagement', {\n        page: pageName,\n        timeSpent: finalTime,\n      });\n    };\n\n    window.addEventListener('beforeunload', handleBeforeUnload);\n\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      \n      // Track final time\n      const finalTime = Math.floor((Date.now() - startTime.current) / 1000);\n      if (finalTime > 5) { // Only track if user spent more than 5 seconds\n        analytics.track('time_on_page_final', 'engagement', {\n          page: pageName,\n          timeSpent: finalTime,\n        });\n      }\n    };\n  }, [pageName]);\n\n  return timeSpent;\n}\n\n// Hook for tracking element visibility (intersection observer)\nexport function useVisibilityTracking(\n  elementRef: React.RefObject<HTMLElement>,\n  eventName: string,\n  properties?: Record<string, any>,\n  threshold: number = 0.5\n) {\n  const [isVisible, setIsVisible] = useState(false);\n  const hasTracked = useRef(false);\n\n  useEffect(() => {\n    const element = elementRef.current;\n    if (!element) return;\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        const visible = entry.isIntersecting && entry.intersectionRatio >= threshold;\n        setIsVisible(visible);\n        \n        if (visible && !hasTracked.current) {\n          analytics.track(eventName, 'engagement', properties);\n          hasTracked.current = true;\n        }\n      },\n      { threshold }\n    );\n\n    observer.observe(element);\n\n    return () => {\n      observer.unobserve(element);\n    };\n  }, [elementRef, eventName, properties, threshold]);\n\n  return isVisible;\n}\n\n// Hook for tracking clicks with analytics\nexport function useClickTracking() {\n  const trackClick = useCallback(\n    (eventName: string, properties?: Record<string, any>) => {\n      return (event: React.MouseEvent) => {\n        // Get click details\n        const clickProperties = {\n          ...properties,\n          elementType: (event.target as HTMLElement).tagName.toLowerCase(),\n          elementText: (event.target as HTMLElement).textContent?.slice(0, 100),\n          clickX: event.clientX,\n          clickY: event.clientY,\n          timestamp: Date.now(),\n        };\n\n        analytics.track(eventName, 'engagement', clickProperties);\n      };\n    },\n    []\n  );\n\n  // Specific tracking functions\n  const trackCTAClick = useCallback(\n    (ctaText: string, location: string) => {\n      return trackClick('cta_click', { ctaText, location });\n    },\n    [trackClick]\n  );\n\n  const trackLinkClick = useCallback(\n    (linkText: string, destination: string) => {\n      return trackClick('link_click', { linkText, destination });\n    },\n    [trackClick]\n  );\n\n  const trackButtonClick = useCallback(\n    (buttonText: string, buttonType: string) => {\n      return trackClick('button_click', { buttonText, buttonType });\n    },\n    [trackClick]\n  );\n\n  return {\n    trackClick,\n    trackCTAClick,\n    trackLinkClick,\n    trackButtonClick,\n  };\n}\n\n// Hook for tracking form interactions\nexport function useFormTracking(formName: string) {\n  const [formState, setFormState] = useState({\n    started: false,\n    completed: false,\n    abandoned: false,\n    errors: 0,\n  });\n\n  const trackFormStart = useCallback(() => {\n    if (!formState.started) {\n      analytics.track('form_start', 'conversion', { formName });\n      setFormState(prev => ({ ...prev, started: true }));\n    }\n  }, [formName, formState.started]);\n\n  const trackFormComplete = useCallback((formData?: Record<string, any>) => {\n    analytics.track('form_complete', 'conversion', {\n      formName,\n      formData: formData ? Object.keys(formData) : undefined,\n    });\n    setFormState(prev => ({ ...prev, completed: true }));\n  }, [formName]);\n\n  const trackFormError = useCallback((errorField: string, errorMessage: string) => {\n    analytics.track('form_error', 'error', {\n      formName,\n      errorField,\n      errorMessage,\n    });\n    setFormState(prev => ({ ...prev, errors: prev.errors + 1 }));\n  }, [formName]);\n\n  const trackFieldFocus = useCallback((fieldName: string) => {\n    analytics.track('form_field_focus', 'engagement', {\n      formName,\n      fieldName,\n    });\n  }, [formName]);\n\n  // Track form abandonment on unmount\n  useEffect(() => {\n    return () => {\n      if (formState.started && !formState.completed) {\n        analytics.track('form_abandon', 'conversion', {\n          formName,\n          errors: formState.errors,\n        });\n      }\n    };\n  }, [formName, formState]);\n\n  return {\n    formState,\n    trackFormStart,\n    trackFormComplete,\n    trackFormError,\n    trackFieldFocus,\n  };\n}\n\n// Hook for tracking performance metrics\nexport function usePerformanceTracking() {\n  const [metrics, setMetrics] = useState<Record<string, number>>({});\n\n  const trackMetric = useCallback((name: string, value: number, unit: string = 'ms') => {\n    setMetrics(prev => ({ ...prev, [name]: value }));\n    trackPerformance(name, value, unit);\n  }, []);\n\n  const trackLoadTime = useCallback((componentName: string, startTime: number) => {\n    const loadTime = performance.now() - startTime;\n    trackMetric(`${componentName}_load_time`, loadTime);\n    return loadTime;\n  }, [trackMetric]);\n\n  const trackRenderTime = useCallback((componentName: string, renderFn: () => void) => {\n    const startTime = performance.now();\n    renderFn();\n    const renderTime = performance.now() - startTime;\n    trackMetric(`${componentName}_render_time`, renderTime);\n    return renderTime;\n  }, [trackMetric]);\n\n  return {\n    metrics,\n    trackMetric,\n    trackLoadTime,\n    trackRenderTime,\n  };\n}\n\n// Hook for tracking errors\nexport function useErrorTracking() {\n  const trackComponentError = useCallback(\n    (error: Error, componentName: string, props?: Record<string, any>) => {\n      trackError(error, `Component: ${componentName}`);\n      analytics.track('component_error', 'error', {\n        componentName,\n        errorMessage: error.message,\n        props: props ? Object.keys(props) : undefined,\n      });\n    },\n    []\n  );\n\n  const trackAsyncError = useCallback(\n    (error: Error, operation: string, context?: Record<string, any>) => {\n      trackError(error, `Async Operation: ${operation}`);\n      analytics.track('async_error', 'error', {\n        operation,\n        errorMessage: error.message,\n        context,\n      });\n    },\n    []\n  );\n\n  const trackNetworkError = useCallback(\n    (error: Error, url: string, method: string = 'GET') => {\n      trackError(error, `Network: ${method} ${url}`);\n      analytics.track('network_error', 'error', {\n        url,\n        method,\n        errorMessage: error.message,\n      });\n    },\n    []\n  );\n\n  return {\n    trackComponentError,\n    trackAsyncError,\n    trackNetworkError,\n  };\n}\n\n// Hook for A/B testing and feature flags\nexport function useExperimentTracking() {\n  const trackExperiment = useCallback(\n    (experimentName: string, variant: string, properties?: Record<string, any>) => {\n      analytics.track('experiment_view', 'engagement', {\n        experimentName,\n        variant,\n        ...properties,\n      });\n    },\n    []\n  );\n\n  const trackConversion = useCallback(\n    (experimentName: string, variant: string, conversionType: string) => {\n      analytics.track('experiment_conversion', 'conversion', {\n        experimentName,\n        variant,\n        conversionType,\n      });\n    },\n    []\n  );\n\n  return {\n    trackExperiment,\n    trackConversion,\n  };\n}\n\n// Hook for tracking user preferences\nexport function usePreferenceTracking() {\n  const trackPreferenceChange = useCallback(\n    (preferenceName: string, oldValue: any, newValue: any) => {\n      analytics.track('preference_change', 'engagement', {\n        preferenceName,\n        oldValue: String(oldValue),\n        newValue: String(newValue),\n      });\n    },\n    []\n  );\n\n  const trackThemeChange = useCallback(\n    (theme: 'light' | 'dark') => {\n      trackConversion.themeToggle(theme);\n    },\n    []\n  );\n\n  return {\n    trackPreferenceChange,\n    trackThemeChange,\n  };\n}\n\n// Hook for tracking social interactions\nexport function useSocialTracking() {\n  const trackSocialShare = useCallback(\n    (platform: string, content: string, url?: string) => {\n      trackConversion.socialShare(platform, content);\n      analytics.track('social_share_detailed', 'engagement', {\n        platform,\n        content,\n        url,\n      });\n    },\n    []\n  );\n\n  const trackSocialClick = useCallback(\n    (platform: string, action: string) => {\n      analytics.track('social_click', 'engagement', {\n        platform,\n        action,\n      });\n    },\n    []\n  );\n\n  return {\n    trackSocialShare,\n    trackSocialClick,\n  };\n}"